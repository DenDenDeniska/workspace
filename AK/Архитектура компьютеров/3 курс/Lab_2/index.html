<!doctype html>
<html>
<head><meta charset="utf-8"><link rel=stylesheet href="../style.css"><title>CPU x86-64</title>
</head>
<body>
<a href="../index.html">Содержание</a>
<h1>Лабораторная работа 2. Архитектура прикладного уровня CPU x86-64</h1>
<hr>
<h2>2.1 Цель работы</h2>
<p>Углубление и закрепление знаний архитектуры прикладного уровня 32-разрядных процессоров семейства x86-64; получение практических навыков по составлению программ на языке ассемблера процессоров x86-64, их отладке и выполнению.</p>

<h2>2.2 Самостоятельная работа студентов</h2>
<p>Перед выполнением лабораторной работы студенты должны изучить регистровую модель, базовые типы и форматы данных, ознакомиться с системой команд языка ассемблера СPU х86-64 (<a target="_blank" href="../CA_appendix.pdf#%5B%7B%22num%22%3A15%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C54%2C790%2C0%5D">приложение А</a>).</p>
<p>При подготовке к выполнению практических заданий следует обратить особое внимание на группы команд целочисленной арифметики, команды сдвигов и команды условных переходов.</p>
<p>Также необходимо иметь представление о работе с программной средой Visual C++ и ее функциональных возможностях в контексте создания и отладки ассемблерных программ, встраиваемых в тело программы на языке C++.</p>

<h2>2.3	Примеры выполнения практических заданий</h2>
<p>2.3.1 Вычислить 7 значений функции Y = (15 * х^2 – 12) / (4 * x + 5) (х изменяется от 3 с шагом 3). Результат округлить до целого и разместить в памяти.</p>
<listing>
void main ()				// начало программы на языке С++
{
	long	X=3;			// ячейка памяти для аргумента
	long	REZ[7];			// 7 ячеек памяти для результатов

	_asm
	{				; начало ассемблерной вставки
	lea	EBX, REZ		; загрузка адреса результатов в регистр EBX
	mov	ECX, 7			; счетчик количества повторений цикла
m1:	mov	EAX, 4			; EAX = 4
	imul	X			; EAX = 4 * x
	add	EAX, 5			; EAX = 4 * x + 5
	mov	EDI, EAX		; пересылка знаменателя в регистр EDI
	mov	EAX, 15			; EAX = 15
	imul	X			; EAX = 15 * x
	imul	X			; EAX = 15 * x^2
	sub	EAX, 12			; EAX = 15 * x2 – 12
	cdq				; расширение операнда-делимого в EAX-EDX
	div	EDI			; частное – EAX, остаток – EDX
	shr	EDI, 1			; деление знаменателя (делителя) на 2
	cmp	EDI, EDX		; сравнение половины делителя с остатком
	adc	EAX, 0			; добавление к частному заема от сравнения
	mov	dword ptr[EBX], EAX	; пересылка результата в память
	add	EBX, 4			; увеличение адреса результатов
	add	X, 3			; увеличение аргумента
	loop	m1			; зацикливание по счетчику в ЕСХ
	}				// окончание ассемблерной вставки
}
</listing>
<p></p>
<p>2.3.2 Определить номер (n) элемента последовательности an = 8^n – 5 * n, при котором сумма элементов последовательности превысит 10000.</p>
<listing>
void main ()			// начало программы на языке С++
{
	long	N=0;		// ячейка памяти для аргумента
	long	S=0;		// ячейка для хранения суммы
	long	P=1; 		// ячейка для накопления 8n	

	_asm
	{			; начало ассемблерной вставки
m1:	inc	N		; увеличение аргумента
	mov	EAX, 8		; EAX = 8
	mul	P		; умножение – 8^n
	mov	P, EAX		; пересылка 8^n в ячейку памяти Р
	add	S, EAX		; накопление суммы
	mov	EAX, 5		; EAX = 5
	mul	N		; EAX = 5 * n
	sub	S, EAX		; накопление суммы
	cmp	S, 10000	; сравнение суммы с 10000
	jc	m1		; переход, если сумма меньше 10000
	}			// окончание ассемблерной вставки
}
</listing>
<p></p>
<p>2.3.3 В памяти задан массив из 5 элементов. Поместить в регистр EAX максимальный элемент массива, а в регистр EDI - его адрес в памяти.</p>
<listing>
void main () {	
	long	x[5]={23, 56, 84, 15, 74}	// массив в памяти

	_asm
	{					; начало ассемблерной вставки
	lea	EBX, x				; начальный адрес массива – в ЕВХ
	mov	ECX, 4				; счетчик повторений
	mov	EAX, dword ptr[EBX]		; первый элемент – в ЕАХ
m2:	add	EBX, 4				; увеличение адреса
	cmp	EAX, dword ptr[EBX]		; сравнение со следующим элемент.
	jnc	m1				; переход, если больше
	mov	EAX, dword ptr[EBX]		; больший элемент – в ЕАХ
	mov	EDI, EBX			; адрес элемента – в EDI
m1:	loop	m2				; зацикливание по счетчику
	}
}
</listing>
<p></p>
<p>2.3.4 В памяти задан массив из 8 элементов. Отсортировать элементы массива по возрастанию. Пример «пузырьковой сортировки».</p>
<listing>
void main () {
	
long	x[8]={7, 23, 56, 33, 84, 15, 11, 74};
	_asm
	{
	mov	EDX, 7			; счетчик внешнего цикла - на 1 меньше
					; количества элементов массива
m3:	lea	EBX, x			; начальный адрес массива
	mov	ECX, EDX		; счетчик внутреннего цикла
m2:	mov	EAX, dword ptr[EBX]	; элемент массива – в ЕАХ
	add	EBX, 4
	cmp	EAX, dword ptr[EBX]	; сравнение соседних элементов
	jc	m1			; переход, если меньше
	xchg	dword ptr[EBX], EAX	; обмен элементов массива
	mov	dword ptr[EBX-4], EAX
m1:	loop	m2			; окончание внутреннего цикла
	dec	EDX			; уменьшение счетчика внешнего цикла
	jnz	m3			; окончание внешнего цикла
	}
}
</listing>
<p></p>

<h2><a name="p2_4"></a>2.4	Порядок выполнения работы</h2>
<p>Выполнение работы состоит в разработке, отладке и выполнении ассемблерных программ в среде разработки Visual C++.</p>
<p>После запуска программы Visual C++ в меню «File» необходимо выбрать команду «New». В открывшемся окне выбрать закладку «Projects», на которой:</p>
<ul>
<li>выбрать «Win32 Console Application»;</li>
<li>в поле «Project name» записать имя проекта (например: lab_1_1 для задания 1, lab_1_2 для задания 2 и т.д.);</li>
<li>в поле «Location» выбрать папку для записи проекта.</li>
</ul>
<p>После формирования папки проекта необходимо ввести программу на языке «С++» с ассемблерной вставкой. Для этого в меню «File» выбрать команду «New». В открывшемся окне выбрать закладку «Files», на которой:</p>
<ul>
<li>выбрать «C++ Source File»;</li>
<li>в поле «File name» записать имя файла.</li>
</ul>
<p>Для компиляции программы необходимо нажать клавишу «F5».</p>
<p>Для пошаговой отладки программы необходимо:</p>
<ul>
<li>установить курсор в начале первой строки ассемблерной вставки;</li>
<li>в меню «Build» выбрать команду «Start Debug» и вариант «Run to Cursor» (или нажать «Ctrl-F10»).</li>
</ul>
<p>Каждый шаг отлаживается нажатием на кнопку «F10».</p>
<p>При пошаговой отладке промежуточные результаты необходимо контролировать в регистрах CPU или ячейках RAM. С этой целью следует открыть окна «Registers» и «Memory» из меню «Debug»->«Windows». Данная возможность становится доступной после того, как отладка была начата.</p>
<p>В окне «Registers» выбор отображаемых элементов программной модели CPU производится посредством контекстного меню данного окна (рисунок 1.1).</p>
<p class="center"><img src="fig_2_1.png" alt="Рисунок 2.1" /></p>
<p class="center">Рисунок 2.1 – Окно отладки «Registers»</p>
<p></p>
<p>В процессе отладки возможно иметь доступ к четырем независимым областям памяти (элементы «Memory n» меню «Memory» на рисунке 1.2).</p>
<p class="center"><img src="fig_2_2.png" alt="Рисунок 2.2" /></p>
<p class="center">Рисунок 2.2 – Выбор областей памяти</p>
<p></p>
<p>В окне «Memory n», отображающем выбранную область памяти (например «Memory 1», как показано на рис. 2.3), посредством контекстного меню и поля ввода «Columns» рекомендуется установить соответствующие параметры отображения. Установку начального адреса области памяти следует выполнить с помощью поля ввода «Address».</p>
<p class="center"><img src="fig_2_3.png" alt="Рисунок 2.3" /></p>
<p class="center">Рисунок 2.3 – Окно отладки «Memory 1»</p>
<p></p>
<p>Результаты выполнения программы представить в десятичном и шестнадцатиричном форматах.</p>

<h2>2.5 Варианты индивидуальных заданий</h2>

<h4>2.5.1 Исследование выполнения арифметических операций.</h4>
<p><u>Вариант 1.</u> Вычислить 7 значений функции Y = 7500 / (2 * х^2 + 15) (х изменяется от 3 с шагом 5). Результат округлить до целого и разместить в памяти.</p>
<p><u>Вариант 2.</u> Вычислить 6 значений функции Y = (6 * х^2 + 12) / (5 * x – 8) (х изменяется от 2 с шагом 4). Результат округлить до целого и разместить в памяти.</p>
<p><u>Вариант 3.</u> Вычислить 8 значений функции Y = 5 * x^2 + 2 * x – 14 (х изменяется от 2 с шагом 4). Результат разместить в памяти.</p>
<p><u>Вариант 4.</u> Вычислить 5 значений элементов последовательности a<sub>n</sub> = 2 * n^2 + 5 (для n от 4 с шагом 1). Результат разместить в памяти.</p>
<p><u>Вариант 5.</u> Вычислить 6 значений функции Y = (2500 * х – 8) / (3 * х^2 + 20) (х изменяется от 4 с шагом 3). Результат округлить до целого и разместить в памяти.</p>
<p><u>Вариант 6.</u> Вычислить 6 значений элементов последовательности an = (3^n) / (n + 5) (для n от 1 с шагом 1). Результат округлить до целого и разместить в памяти.</p>
<p><u>Вариант 7.</u> Вычислить 8 значений функции Y = (8 * х^2 + 12 * х – 7) / (3 * x + 25) (x изменяется от 2 с шагом 3). Результат округлить до целого и разместить в памяти.</p>
<p><u>Вариант 8.</u> Вычислить 7 значений функции Y = 7 * x^2 + 12 * x – 32 (х изменяется от 3 с шагом 4). Результат разместить в памяти.</p>
<p><u>Вариант 9.</u> Вычислить 6 значений функции Y = (6^х + 12) /(4* x^2 – 3) (х изменяется от 1 с шагом 1). Результат округлить до целого и разместить в памяти.</p>
<p><u>Вариант 10.</u> Вычислить 7 значений элементов последовательности an = 3 * n^2 + 11 (для n от 4 с шагом 1). Результат разместить в памяти.</p>

<h4>1.5.2 Исследование выполнения операций сравнения. </h4>
<p><u>Вариант 1.</u> Найти целое значение аргумента, при котором функция Y = 20000 / (8 * x^2 + 25) станет меньше 20.</p>
<p><u>Вариант 2.</u> Определить номер (n) элемента последовательности a<sub>n</sub> = n^2 +6 * n + 28, при котором сумма элементов последовательности превысит 1000.</p>
<p><u>Вариант 3.</u> Найти целое значение аргумента, при котором функция Y = 15 * x^2 + 11 * x – 16 станет больше 2000.</p>
<p><u>Вариант 4.</u> Найти целое значение аргумента, при котором функция Y = (7^x) / (5 * x^2) превысит 300.</p>
<p><u>Вариант 5.</u> Найти целое значение аргумента, при котором функция Y = (2000 + х) / (8 * x^2 + 25) станет меньше 10.</p>
<p><u>Вариант 6.</u> Найти целое значение аргумента, при котором функция Y = 9 * x^2 – 8 * x + 15 станет больше 1000.</p>
<p><u>Вариант 7.</u> Определить номер (n) элемента последовательности a<sub>n</sub> = 5^n + 8 * n, при котором сумма элементов последовательности превысит 20000.</p>
<p><u>Вариант 8.</u> Найти целое значение аргумента, при котором функция Y = 7 * x^2 + 25 * x – 27 станет больше 3000.</p>
<p><u>Вариант 9.</u> Найти целое значение аргумента, при котором функция Y = 300 * х / (8^x + 14) станет меньше 5.</p>
<p><u>Вариант 10.</u> Определить номер (n) элемента последовательности a<sub>n</sub> = 3* n^2 – 5 * n + 12, при котором сумма элементов последовательности превысит 1500.</p>

<h4>2.5.3 Исследование выполнения операций над массивами в памяти.</h4>
<p><u>Вариант 1.</u> В памяти задан массив из 10 элементов. Поместить в регистр EAX минимальный элемент массива, а в регистр EDX его адрес в памяти.</p>
<p><u>Вариант 2.</u> В памяти задан массив из 10 элементов. Сохранить в регистре ESI количество отрицательных элементов.</p>
<p><u>Вариант 3.</u> Рассчитать и сохранить в памяти элементы массива, заданные функцией Y = n! (для n от 1 до 8)</p>
<p><u>Вариант 4.</u> В памяти задан массив из 10 элементов. Заменить эти числа произведением их старшего и младшего слова.</p>
<p><u>Вариант 5.</u> В памяти задан массив из 8 элементов. Поместить в регистр EAX максимальный элемент массива, а в регистр ESI его адрес в памяти.</p>
<p><u>Вариант 6.</u> В памяти задан массив из 9 элементов. Отсортировать элементы массива по возрастанию.</p>
<p><u>Вариант 7.</u> В памяти задан массив из 10 элементов. Сохранить в регистре ESI количество нечетных элементов.</p>
<p><u>Вариант 8.</u> В памяти задан массив из 12 элементов. Сохранить в регистре ЕАХ среднее арифметическое этих элементов. Результат округлить до целого.</p>
<p><u>Вариант 9.</u> В памяти задан массив из 10 элементов. Сохранить в регистре ESI количество единичных битов во всех элементах.</p>
<p><u>Вариант 10.</u> В памяти задан массив из 11 элементов. Отсортировать элементы массива по убыванию.</p>
<p></p>

<h2>2.6 Содержание отчета</h2>
<p>Отчет о лабораторной работе должен содержать:
<ul>
<li>цель работы;</li>
<li>краткое описание теоретических основ;</li>
<li>постановку задачи;</li>
<li>экспериментально-практическую часть (включая анализ результатов);</li>
<li>выводы по работе.</li>
</ul>
<p>В экспериментально-практической части необходимо привести исходные тексты разработанных программ (на языке C++ с ассемблерными вставками) и результаты их выполнения, полученные в регистрах CPU и (или) ячейках памяти.</p>

<h2>2.7 Контрольные вопросы</h2>
<ol>
<li>Что представляет собой программная модель 32-разрядных процессоров х86-64?</li>
<li>Перечислите форматы данных процессоров х86-64.</li>
<li>Для чего нужны форматы двоично-десятичных чисел?</li>
<li>Перечислите методы (способы) адресации данных в процессорах х86-64.</li>
<li>Перечислите команды пересылки данных и варианты расположения операндов-приемников и операндов-источников.</li>
<li>Перечислите арифметические и логические команды.</li>
<li>Где могут располагаться операнды команд умножения и деления, и куда могут записываться их результаты?</li>
<li>Какие команды позволяют обрабатывать десятичные данные без перевода их в двоичный формат?</li>
<li>Как выполняются команды сдвигов?</li>
<li>Перечислите цепочечные (строковые) команды и особенности их выполнения.</li>
<li>Как выполняются команды условных и безусловных переходов?</li>
<li>Чем отличаются команды JMP и CALL?</li>
</ol>
</body>
</html>
