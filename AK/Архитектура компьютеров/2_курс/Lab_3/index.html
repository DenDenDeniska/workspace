<!doctype html>
<head>
<meta charset="windows-1251">
<link rel=stylesheet href="../style.css">
<title>Способы адресации команд и данных</title>
</head>

<body>
<a href="../index.html">Содержание</a>
<h1>Лабораторная работа 3. Способы адресации команд и данных</h1>
<hr>
<h2>3.1. Цель работы</h2>
<p>Изучение методов адресации команд и данных в компьютерах, принципов логической организации аппаратных средств процессора, обеспечивающих доступ к памяти.</p>
<h2>3.2. Порядок выполнения работы </h2>
<p>Студенты должны внимательно прочитать информационную часть работы, ознакомиться 
    с методами адресации данных в компьютерах, выяснить причины использования 
    таких понятий, как подразумеваемый операнд и подразумеваемый адрес. Практическая 
    часть выполняется в соответствии с вариантом задания из табл. 3.1. </p>
<p class="center">Таблица 3.1 - Варианты заданий</p>
<table width="100%" align="center">
      <tr> 
        <th height="34" rowspan="2">Вариант</th>
        <th height="20" colspan="3">Методы адресации</th>
      </tr>
      <tr> 
        <th>1</th>
        <th>2</th>
        <th>3</th>
      </tr>	  
      <tr> 
        <td>1</td>
        <td><a href="direct.html">Direct</a></td><td><a href="indexed.html">Index</a></td><td><a href="baseindexs.html">Base index with scaling</a></td>
      </tr>
      <tr> 
        <td>2</td>
        <td><a href="regind.html">Register indirect</a></td><td><a href="indexedsc.html">Index with scaling</a></td><td><a href="baseindexo.html">Base index with offset</a></td>
      </tr>
      <tr> 
        <td>3</td>
        <td><a href="based.html">Base</a></td><td> <a href="baseindexs.html">Base index with scaling</a></td><td><a href="baseindexo.html">Base index with offset</a></td>
      </tr>
      <tr> 
        <td>4</td>
        <td><a href="indexedsc.html">Index with scaling</a></td><td><a href="direct.html">Direct</a></td><td><a href="baseindexso.html">Base index with offset and scaling</a></td>
      </tr>
      <tr> 
        <td>5</td>
        <td><a href="regind.html">Register indirect</a></td><td> <a href="indexedsc.html">Index with scaling</a></td><td><a href="baseindex.html">Base index</a></td>
      </tr>
      <tr> 
        <td>6</td>
        <td><a href="baseindex.html">Base index</a></td><td><a href="indexed.html">Index</a></td><td><a href="baseindexso.html">Base index with offset and scaling</a></td>
      </tr>
      <tr> 
        <td>7</td>
        <td><a href="baseindexo.html">Base index with offset</a></td><td><a href="regind.html">Register indirect</a></td><td><a href="baseindex.html">Base index </a></td>
      </tr>
      <tr> 
        <td>8</td>
        <td><a href="baseindex.html">Base index</a></td><td><a href="based.html">Base</a></td><td><a href="baseindexso.html">Base index with offset and scaling</a></td>
      </tr>
      <tr> 
        <td>9</td>
        <td><a href="indexed.html">Index</a></td><td><a href="baseindexso.html"> Base index with offset and scaling</a></td><td><a href="regind.html">Register indirect</a></td>
      </tr>
      <tr> 
        <td>10</td>
        <td><a href="baseindexo.html">Base index with offset</a></td><td><a href="indexedsc.html">Index with scaling</a></td><td><a href="direct.html">Direct</a></td>
      </tr>
</table>
    <p>Перейти в раздел &quot;Схема адресации&quot;, ссылка на который приведена 
      в конце информационной части методических указаний. Для трех заданных режимов 
      адресации переписать выражения для вычисления линейного адреса, примеры 
      команд и нарисовать соответствующие схемы формирования LA .</p>
    <p> Перейти в раздел &quot;Моделирование&quot; и выполнить следующие процедуры:</p>
    <ul> 
      <li>выбрать размер данных BYTE; размер сегмента - 96 байт;</li>
      <li>базовый адрес сегмента рассчитать по формуле:</li>
      <p class="center"> (N_вар mod 6 + 1) * 16;</p>
      <li>эффективный адрес операнда:</li>
      <p class="center"> EA = (N_вар mod 5 + 1) * 14.</p>
      <p>Значение базы, индекса, смещения: произвольные ненулевые, подбираются в соответствии с условиями, приведенными выше.</p>
      <li>В соответствии с полученными значениями наберите числовые данные в окнах Адрес сегмента, Размер сегмента, Смещение и т.д.;</li>
      <li>постройте таблицу для заданных в табл. 3.1 методов адресации (по примеру табл. 3.2).</li>
    </ul>
    <h2>3.3. Содержание отчета</h2>
      <p>Отчет по работе должен содержать: цель работы, общие теоретические сведения 
        об используемых в компьютерах способах адресации команд и данных, схемы 
        формирования LA, результаты вычисления LA в табличном виде (табл. 3.2), выводы по работе.</p>
<p class="center">Таблица 3.2 - Формирование линейного адреса </p>
<div align="center"> 
      <table width="80%"
    cols="9">
        <tr class="center"> 
          <th width="15%">Способ адресации</th>
          <th width="15%">Размер сегмента</th>
          <th width="15%">Начальный адрес сегмента</th>
          <th width="10%">База</th>
          <th width="10%">Индекс</th>
          <th width="10%">Масштаб</th>
          <th width="10%">Смещение</th>
          <th width="15%">Линейный адрес</th>
        </tr>
        <tr> 
          <td> 
            <div align="center">Base index with offset and scaling</div>
          </td>
          <td> 
            <div align="center">50</div>
          </td>
          <td> 
            <div align="center">2</div>
          </td>
          <td> 
            <div align="center">10</div>
          </td>
          <td> 
            <div align="center">5 </div>
          </td>
          <td> 
            <div align="center">1</div>
          </td>
          <td> 
            <div align="center">20 </div>
          </td>
          <td> 
            <div align="center">37<sub>10</sub> = 25h</div>
          </td>
        </tr>
        <tr> 
          <td> 
            <div align="center">Base index with offset</div>
          </td>
          <td> 
            <div align="center">50</div>
          </td>
          <td> 
            <div align="center">2</div>
          </td>
          <td> 
            <div align="center">10 </div>
          </td>
          <td> 
            <div align="center">5</div>
          </td>
          <td> 
            <div align="center"></div>
          </td>
          <td> 
            <div align="center">20 </div>
          </td>
          <td> 
            <div align="center">37<sub>10</sub> = 25h</div>
          </td>
        </tr>
        <tr> 
          <td> 
            <div align="center">Direct</div>
          </td>
          <td> 
            <div align="center">50</div>
          </td>
          <td> 
            <div align="center">2</div>
          </td>
          <td> 
            <div align="center"></div>
          </td>
          <td> 
            <div align="center"></div>
          </td>
          <td> 
            <div align="center"></div>
          </td>
          <td> 
            <div align="center">35</div>
          </td>
          <td> 
            <div align="center">37<sub>10</sub> = 25h</div>
          </td>
        </tr>
      </table>
</div>
  <p><b>Примечание:</b> в том случае, когда в формуле формирования линейного адреса участвует 
    параметр масштабирования (Scale) для каждого размера операнда необходимо получить 
    дополнительные значения LA для значений параметра Масштаб 1, 2, 4 и 8. </p>
  <h2>3.4. Принципы адресации команд и данных</h2>
  <p>В компьютерах, процессоры которых оснащены регистрами общего назначения, 
    метод адресации объектов, которыми манипулирует команда, может задавать константу, 
    регистр или ячейку памяти. Для обращения к ячейке памяти процессор должен, 
    прежде всего, вычислить <i>эффективный</i> или <i>исполнительный адрес</i> 
    памяти А<sub>и</sub>, который определяется используемым в команде методом 
    адресации. Исполнительный адрес – это номер ячейки памяти, к которой производится 
    фактическое обращение.</p>
  <p> При рассмотрении методов адресации следует выделить понятие <i>подразумеваемого 
    операнда</i> и <i>подразумеваемого адреса</i>. </p>
  <p align="left">Понятие <i>подразумеваемого операнда</i> предполагает, что команда 
    не содержит в явном виде адреса операнда; операнд подразумевается и фактически 
    определяется кодом операции. Данный способ имеет несколько важных случаев 
    применения. В качестве примера можно привести команды подсчета, в которых 
    к некоторому числу, находящемуся в одном из регистров, прибавляется фиксированное 
    приращение. В результате, один из операндов команды (номер регистра) адресуется 
    явным методом, а второй операнд – приращение – не адресуется, в памяти компьютера 
    не содержится и является подразумеваемым.</p>
  <p>Понятие <i>подразумеваемого адреса</i> предполагает, что в команде не содержится 
    явных указаний об адресе участвующего в операции операнда или адреса, по которому 
    помещается результат операции. В то же время этот адрес подразумевается. Примером 
    может служить команда, которая содержит адреса обоих операндов, участвующих 
    в операции, при этом подразумевается, что результат операции будет помещен 
    по адресу одного из операндов. Другим примером может служить команда, в которой 
    указан адрес только одного операнда, а адрес второго, которым является содержимое 
    специального регистра, подразумевается. </p>
  <p>В таблице 3.3 на примере команды сложения (Add) приведены наиболее употребительные 
    названия методов адресации операндов, которые реализованы в компьютерах общего 
    назначения.</p>
  <p>&nbsp;</p>
<p class="center">Таблица 3.3 – Основные методы адресации операндов</p>
<div align="center"> 
  <table width="92%">
    <tr class="center"> 
      <th width="19%" height="32">Метод адресации</th>
      <th width="16%" height="32">Пример команды</th>
      <th width="20%" height="32">Описание команды</th>
      <th width="45%" height="32">Использование</th>
    </tr>
    <tr> 
      <td width="19%" height="44">Непосредственная или литеральная </td>
      <td width="16%" height="44"> 
        <div align="center">Add R4, #3 </div>
      </td>
      <td width="20%" height="44"> 
        <div align="center">R4 := R4 + 3 </div>
      </td>
      <td width="45%" height="44">Для задания констант</td>
    </tr>
    <tr> 
      <td width="19%" height="2">Регистровая</td>
      <td width="16%" height="2"> 
        <div align="center">Add R4, R5 </div>
      </td>
      <td width="20%" height="2"> 
        <div align="center">R4 := R4 + R5 </div>
      </td>
      <td width="45%" height="2">Оба операнда и результат находятся в регистрах</td>
    </tr>
    <tr> 
      <td width="19%" height="22">Относительная или базовая</td>
      <td width="16%" height="22"> 
        <div align="center">Add R4, R1, D </div>
      </td>
      <td width="20%" height="22"> 
        <div align="center">R4 := R4+ M[R1+D] </div>
      </td>
      <td width="45%" height="22">Первый операнд – в регистре, второй в памяти 
      </td>
    </tr>
    <tr> 
      <td width="19%" height="30">Абсолютная</td>
      <td width="16%" height="30"> 
        <div align="center">Add R1,(1000) </div>
      </td>
      <td width="20%" height="30"> 
        <div align="center">R1:=R1+ M[1000] </div>
      </td>
      <td width="45%" height="30">Применяется для обращения к статистическим данным 
      </td>
    </tr>
    <tr> 
      <td width="19%" height="17">Косвенная регистровая</td>
      <td width="16%" height="17"> 
        <div align="center">Add R4,(R1) </div>
      </td>
      <td width="20%" height="17"> 
        <div align="center">R4 := R4+ M[R1] </div>
      </td>
      <td width="45%" height="17">Для обращения по указателю или вычисленному 
        адресу </td>
    </tr>
    <tr> 
      <td width="19%" height="29">Индексная</td>
      <td width="16%" height="29"> 
        <div align="center">Add R3,(R1+R2) </div>
      </td>
      <td width="20%" height="29"> 
        <div align="center">R3 := R3 + M[R1+R2] </div>
      </td>
      <td width="45%" height="29"> 
        <p>Применяется при работе с массивми:<br>
          R1 - база, R2 - индекс </p>
      </td>
    </tr>
    <tr> 
      <td width="19%" height="48"> Автоинкрементная</td>
      <td width="16%" height="48"> 
        <div align="center">Add R1,(R2)+ </div>
      </td>
      <td width="20%" height="48"> 
        <div align="center">R1:= R1+M[R2]; <br>
          R2 := R2+d </div>
      </td>
      <td width="45%" height="48">Используется для прохода в цикле по массиву 
        с шагом. R2 – начало массива.<br>
        В каждом цикле R2 получает приращение d </td>
    </tr>
    <tr> 
      <td width="19%" height="21">Автодекрементная</td>
      <td width="16%" height="21"> 
        <div align="center">Add R1,(R2)- </div>
      </td>
      <td width="20%" height="21"> 
        <div align="center">R1 := R1+M[R2]; <br>
          R2 := R2-d</div>
      </td>
      <td width="45%" height="21">Аналогична предыдущей. Обе могут использоваться 
        для реализации стека </td>
    </tr>
    <tr> 
      <td width="19%" height="31">Безадресная </td>
      <td width="16%" height="31"> 
        <div align="center"></div>
      </td>
      <td width="20%" height="31"> 
        <div align="center"></div>
      </td>
      <td width="45%" height="31">Безадресное задание операндов </td>
    </tr>
  </table>
</div>
<p>Обычно в компьютерах одновременно используется несколько типов адресации. 
      В команде тип адресации может задаваться либо неявно кодом операции, либо 
      в явной форме в специальном поле адресной части команды. </p>
  <h2>3.4.1. Непосредственная или литеральная адресация </h3>
  <p>При непосредственной или литеральной адресации в команде содержится не адрес 
    операнда, а сам операнд. При выполнении такой команды не требуется обращения 
    к памяти для выборки операнда. Непосредственная адресация используется при 
    выполнении арифметических операций, операций сравнения, а также для загрузки 
    констант в регистры. Применение непосредственной адресации позволяет значительно 
    уменьшить время выполнения программ, а также занимаемого ими объема памяти. 
    Учитывая, что частота использования команд с непосредственной адресацией в 
    различных программах колеблется от 17% до 43%, можно сделать вывод об эффективности 
    такого метода адресации.</p>
  <h3>3.4.2. Прямая регистровая адресация</h3>
  <p>Применение прямой или регистровой адресации предполагает, что исполнительный 
    адрес совпадает с адресной частью команды. Этот способ адресации был общепринятым 
    в машинах первых поколений и продолжает применяться в современных компьютерах 
    в комбинации с другими способами.</p>
  <h3>3.4.3. Относительная адресация </h3>
  <p>При относительной адресации исполнительный адрес определяется суммой базового 
    адреса А<sub>б</sub> и смещения D. Для хранения базовых адресов в процессорах 
    предусмотрены специальные регистры. В примере, приведенном в таблице 3.3, 
    для хранения базового адреса используется регистр R1. Кроме того, в адресной 
    части команды выделяется поле, в котором размещается смещение D. Исполнительный 
    адрес формируется:</p>
<p class="center">А<sub>и</sub> = А<sub>б</sub> + D.</p>
    <p class="center"><img src="Image_2_1.png"></p>
    <p class="center">Рисунок 3.1 - Относительная адресация;<br>
      а) образование адреса элемента одномерного массива;<br>
      б) формирование исполнительного адреса<br>
    </p>
  <p>Применение в компьютерах относительной адресации позволяет при незначительной 
    длине адресного кода команды обеспечить доступ к любой ячейке памяти. Количество 
    разрядов регистра хранения базового адреса А<sub>б</sub> выбирается таким, 
    чтобы можно было задавать начало массива во всем адресном пространстве оперативной 
    памяти, а адресный код смещения D определяет положение операнда относительно 
    начала массива. Процесс формирования исполнительного адреса при относительной 
    адресации показан на рисунке 3.1. В этом случае исполнительный адрес формируется 
    на выходе сумматора согласно выражению:</p>
    <p class="center">А<sub>и </sub>=[B]+D,</p>
    <p>где B и D – коды адресной части, стоящие в соответствующих 
      полях команды; [В]– содержимое регистра с номером В.</p>

  <p>В том случае, если В = 0, исполнительный адрес равен D.</p>
  <p>Формально обращение к памяти при относительной адресации можно представить 
    в виде следующей последовательности процедур:</p>
<listing>
	<u>если</u> РгК[В] = 0, <u>то</u> РгАОП := РгК[D];
	<u>иначе</u> РгАОП := [РгВ] + РгКОП[РгАОП]. [D];
	<u>считывание</u>: БРгОП := Ячейка;
</listing>
  <p>Формирование исполнительного адреса при относительной адресации путем суммирования 
    связано с потерей времени. Поэтому иногда применяется процедура получения 
    исполнительного адреса, получившая название операции конкатенации (совмещения) 
    слова:</p>
 
	<p class="center">РгАОП := [РгВ]\РгК[D],</p>
 
      <p>где \ - символ операции конкатенации. </p>

    <p>На рисунке 3.2 показана процедура получения исполнительного адреса на основе 
      операции конкатенации.</p>
    <p class="center"><img src="Image_2_2.png"> </p>
    <p class="center"> Рисунок 3.2 - Формирование исполнительного адреса<br>
      методом конкатенации</p>
    <p>Учитывая, что относительная адресация для различных программ составляет 
      от 32% до 55%, можно сделать вывод о том, что применение операции совмещения 
      при относительной адресации позволяет повысить скорость формирования адреса 
      одного из операндов и производительность процессора в целом. </p>
    <p>Относительная адресация обеспечивает так называемую перемещаемость программ 
      в памяти компьютера, т. е. размещение программ в свободных участках памяти 
      без внесения изменений внутри самой программы. </p>
 
    <h3>3.4.4. Абсолютная адресация</h3>
    <p align="left">При абсолютной адресации исполнительный адрес совпадает с 
      адресной частью команды, т. е.</p>
<p class="center">РгАОП := 1000; БРгОП := Ячейка ОП[1000]. </p>
    <p>Абсолютная адресация была общепринятой в первых вычислительных машинах 
      и продолжает применяться в настоящее время в сочетании с другими методами. 
    </p>

    <h3>3.4.5. Косвенная адресация</h3>
    <p align="left">При косвенной адресации адресное поле команды указывает адрес 
      ячейки памяти, в которой находится адрес операнда или команды. Таким образом, 
      косвенная адресация может быть определена как &quot;адресация адреса&quot;. 
      Наличие косвенной адресации в команде может определяться кодом операции. 
      Кроме того, в некоторых машинах в команде отводится специальный разряд (указатель адресации - УА) и цифра 0 или 1 в нем указывает, является адресная часть 
      команды прямым адресом или косвенным. Процедуру обращения к оперативной 
      памяти за операндом при косвенной адресации можно описать таким образом:</p>
<listing>
	РгАОП := РгК[R1];
	<u>считывание</u>: БРгОП := Ячейка ОП[РгАОП];
	<u>если</u> УА = 0, <u>то</u> <u>идти к</u> А, <u>иначе</u> РгАОП: = [БРгОП];
	<u>считывание</u>: БРгОП := Ячейка ОП[РгАОП];
	А: РгАЛУ := [БРгОП]; 
</listing>
    <p align="left">В этом случае в регистр адреса оперативной памяти заносится 
      содержимое поля R1 команды. Выполняется процедура считывания содержимого 
      ячейки R1 и в буферном регистре ОП размещается один из операндов. Далее 
      проверяется содержимое указателя адреса. Если УА равен 0 (прямая адресация), 
      происходит переход к метке А, и в регистр АЛУ передается код операнда из 
      буферного регистра оперативной памяти. Если же поле УА содержит 1 (косвенная 
      адресация), то содержимое буферного регистра памяти загружается в адресный 
      регистр памяти. Происходит повторное считывание из оперативной памяти (но 
      из другой ячейки) операнда, который передается в регистр АЛУ.</p>
    <p>На рисунке 3.3 показана логическая организацию устройств, выполняющих команду 
      передачи числа 1234 из Рг5 в ячейку оперативной памяти 5432 с использованием 
      косвенной адресации. Адрес ячейки находится в Рг3. При этом необходимо учитывать, 
      что длина адресных полей команды достаточна лишь для размещения только номеров 
      регистров, т.е. не позволяет задать в команде полный адрес ячейки памяти. 
    </p>
    <p></p>
    <p align="left">&nbsp;</p>
    <p class="center"><img src="Image_2_3.png" /></p>
    <p class="center">Рисунок 3.3 - Пример реализации косвенной адресации<br>
    </p>
    <h3>3.4.6. Индексная адресация </h3>
    <p align="left">Индексная адресация является развитием метода относительной 
      адресации (базирования), с которым она часто используется совместно. Для 
      выполнения индексации в машину вводятся специальные (индексные) регистры, 
      в качестве которых используются ячейки сверхоперативной памяти. В формате 
      команды выделяется поле Х для указания номера индексного регистра (в примере, 
      приведенном в таблице 3.3, в качестве индексного используется регистр R2). 
      Исполнительный адрес операнда при индексации формируется путем суммирования 
      содержимого базового, индексного регистров и смещения D (рис. 3.4).</p>
    <p class="center"><img src="Image_2_4.png" /></p>
    <p class="center">Рисунок 3.4 - Формирование исполнительного адреса при индексации<br>
    </p>
    <h3>3.4.7. Автоинкрементная и автодекрементная адресации </h3>
    <p>Автоинкрементная и автодекрементная адресации имеют механизм автоматического 
      приращения или уменьшения содержимого определенного регистра при каждом 
      обращении к нему. Такой тип адресации особенно эффективен при обработке 
      массивов данных. </p>
    <p>При автоинкрементной адресации сначала содержимое регистра используется 
      как адрес операнда, а затем изменяется путем прибавления константы d, равной 
      числу байт в элементе массива. При автодекрементной адресации сначала содержимое 
      указанного в команде регистра уменьшается на число d, равное числу байт 
      в элементе массива, а затем используется как адрес операнда.</p>
    <p>Автоинкрементная и автодекрементная адресации представляют собой упрощенный 
      вариант индексации и являются важным механизмом преобразования адресных 
      частей команд при организации вычислительных циклов. </p>
    <h3>3.4.8. Стековая память </h3>
    <p>Безадресное задание операндов реализуется посредством стековой памяти, 
      которая является эффективным элементом современной архитектуры компьютеров, 
      начиная персональным компьютером и заканчивая мейнфреймом. </p>
    <p align="left">Стек представляет собой хранилище данных, работа с которым 
      ведется по следующему принципу: элемент, записанный в стек последним, считывается 
      из него первым. Применяются два вида реализации стековой памяти: <ul>
      <li>аппаратный стек, представляющий собой группу последовательно пронумерованных 
      регистров;</li><li>группа ячеек ОП, снабженных указателем стека.</li></ul></p>
    <p class="center"><img src="Image_2_5.png" /></p>
    <p class="center">Рисунок 3.5 - Стековая память</p>
    <p>Рассмотрим наиболее распространенную организацию стека, при которой он 
      заполняется сверху вниз: первый элемент записывается в самый конец области 
      стека (в ячейку с наибольшим адресом), следующий элемент записывается под 
      ним и т. д. При чтении информации из стека первым извлекается последнее 
      поступившее в него слово. Таким образом, получается, что низ стека всегда 
      фиксирован (это последняя ячейка области стека), а вершина стека все время 
      перемещается. Для задания текущего положения вершины стека используется 
      регистр SP (Stack Pointer – указатель стека). В нем хранится адрес той ячейки, 
      в которой находится элемент, записанный в стек последним. Область памяти, 
      выделяемая под стек, называется сегментом стека. Начало сегмента стека указывается 
      в сегментном регистре BP (Base Pointer). В указателе стека SP устанавливается 
      смещение вершины стека, отсчитанное от начала сегмента стека. Поэтому абсолютный 
      адрес вершины стека задается парой регистров BP и SP (рисунок 3.5).</p>
    <p>В стеке автоматически реализуется правило &quot;последний пришел – первый 
      ушел&quot;, поэтому при операциях со стеком возможно безадресное задание 
      операнда. Команда не содержит адреса ячейки стека, но должна содержать адрес 
      ячейки памяти или регистра, откуда слово передается в стек или куда помещается 
      из стека. </p>
    <p>Вычисления с использованием стековой памяти основаны на так называемой 
      бесскобочной записи арифметических выражений (иногда ее называют польской 
      инверсионной записью - ПОЛИЗ). Пусть имеется некоторое выражение</p>
    <table width="90%" border="0" bordercolor="#CCCCCC">
      <tr> 
        <td width="94%"> 
          <div align="center">(a + b)*(с + d):(e*(f - squ g)).</div>
        </td>
        <td width="6%"> 
          <div align="center">(3.1)</div>
        </td>
      </tr>
    </table>
    <p class="center">&nbsp;</p>
    <p>Запись этого выражения в ПОЛИЗ выполняется следующим образом: будем выписывать 
      в строку, слева направо, операнды в том порядке, как они встречаются в данном 
      выражении. Каждый раз, когда окажется, что операнды, необходимые для выполнения 
      какой-либо операции из данного арифметического выражения, все уже выписаны, 
      запишем знак этой операции; если далее окажется, что уже есть все операнды 
      для следующей операции, запишем ее знак, если нет – будем продолжать выписывать 
      по порядку следующие операнды. Если операндом для некоторой операции является 
      результат какой-нибудь из предыдущих операций, то данный операнд считается 
      имеющимся, если написан знак этой предыдущей операции. Преобразуя по этому 
      правилу приведенное выше выражение, получим </p>

        <table width="90%" border="0" bordercolor="#CCCCCC">
          <tr> 
            <td width="94%"> 
              <div align="center">ab + cd + * efg squ - *.</div>
            </td>
            <td width="6%"> 
              <div align="center">(3.2)</div>
            </td>
          </tr>
        </table>

    <p>В полученной записи арифметического выражения порядок действий определен однозначно, хотя скобки в нем не используются. В стековой памяти последовательность символов в выражении ПОЛИЗ, например (3.2), может рассматриваться как программа вычисления исходного арифметического выражения (3.1). На рис. 3.6 приведена последовательность операндов и операций, записанных в стековую память, для вычисления выражения (3.1). При этом, в стек заносятся только адреса операндов, содержащиеся в ОП, и коды операций. Коды операций инициируют извлечение из стека одного или двух операндов, выполнение над ними указанной в команде операции и занесение результата в вершину стека.</p>
      <div align="center"> 
        <center>
          <table border="1" width="20%" cols="1" cellpadding="0" cellspacing ="0">
            <tr> 
              <td> 
                <div align="center">Адрес a </div>
              </td>
            </tr>
            <tr> 
              <td> 
                <div align="center">Адрес b </div>
              </td>
            </tr>
            <tr> 
              <td> 
                <div align="center">+ </div>
              </td>
            </tr>
            <tr> 
              <td> 
                <div align="center">Адрес c </div>
              </td>
            </tr>
            <tr> 
              <td> 
                <div align="center">Адрес d </div>
              </td>
            </tr>
            <tr> 
              <td> 
                <div align="center">+ </div>
              </td>
            </tr>
            <tr> 
              <td> 
                <div align="center">* </div>
              </td>
            </tr>
            <tr> 
              <td> 
                <div align="center">Адрес e </div>
              </td>
            </tr>
            <tr> 
              <td> 
                <div align="center">Адрес f </div>
              </td>
            </tr>
            <tr> 
              <td> 
                <div align="center">Адрес g </div>
              </td>
            </tr>
            <tr> 
              <td> 
                <div align="center">Извлечение корня </div>
              </td>
            </tr>
            <tr> 
              <td> 
                <div align="center">- </div>
              </td>
            </tr>
            <tr> 
              <td> 
                <div align="center">* </div>
              </td>
            </tr>
            <tr> 
              <td> 
                <div align="center">: </div>
              </td>
            </tr>
          </table>
        </center>
      </div>
      <p class="center">Рисунок 3.6 - Программа загрузки стека для вычисления 
        выражения 3.1 </p>
  <p>Безадресные команды с использованием стековой адресации значительно экономят 
    память, сокращают формат команд и повышают производительность компьютеров. 
    Однако безадресное задание операндов имеет ряд недостатков, самым существенным 
    из которых является сложность выполнения команд передачи управления.</p>
  <p>В архитектуре современных компьютеров стековая адресация широко используется 
    при обработке подпрограмм и в системах прерываний.</p>
  <h3>3.4.9. Особенности формирования адреса в процессорах Intel</h3>
  <p>Память для процессоров Intel разбивается на байты (8 бит), слова (16 бит), 
    двойные слова (32 бит). Более крупными единицами являются страницы и сегменты. 
    Память может логически организовываться в виде одного или множества сегментов 
    переменной длины. Метод адресации данных в команде может устанавливать константу, 
    регистр или ячейку памяти. Применительно к памяти различают три адресных пространства: логическое, линейное и физическое. </p>
  <p><i>Логический</i> или <i>виртуальный адрес</i> (рисунок 3.7) состоит из селектора 
    и смещения. При обращении к ячейке памяти процессор сначала должны вычислить 
    <i>эффективный (исполнительный)</i> адрес памяти, который задается данным 
    в команде методом адресации.<i> </i>Эффективный адрес формируется суммированием 
    (в различных сочетаниях) следующих компонентов:</p>
<ul>
    <li> Base (база) - содержимое одного из универсальных регистров. Базовые регистры 
      обычно используются транслятором как начало отметки локальной области памяти;</li>
    <li>Index (индекс) - содержимое одного из универсальных регистров. Индексные 
      регистры обычно используются для доступа к элементам массива или строки;</li>
    <li> Scale (масштабный коэффициент) - значение индексного регистра может быть 
      умножено на коэффициент 1, 2, 4 или 8, использование которого определено 
      в специальном байте поля команды;</li>
    <li> Disp (displacement - смещение в команде) - 8- или 32-разрядное значение, 
      непосредственно задаваемое в команде.</li>
</ul>
  <p><i>Линейный адрес</i> состоит из двух компонент: базового адреса сегмента 
    и эффективного адреса.</p>
  <p>В общем случае исполнительный адрес EA операнда определяется следующей формулой:</p>
  <p class="center"> ЕА = Base + (Index*Scale) + Disp</p>
    <p class="center"><img src="Image_2_6.png" /></p>
    <p class="center">Рисунок 3.7 - Формирование адреса 32-разрядных процессоров</p>
    <p>В качестве примера в разделе &quot;Схема адресации&quot; рассмотрены 
      методы адресации, используемые в процессоре 80386. При этом опущены два 
      режима адресации: один обеспечивает обращение к содержимому какого-либо 
      регистра процессора, другой задает операнд непосредственно в команде. Операнды 
      могут иметь размер 8,16 или 32 бита. </p>
    <h2>3.5. Контрольные вопросы и задания </h2>
<ol>
<li>Почему в современных компьютерах используется несколько методов адресации?</li>
<li>С какой целью в компьютерах применяются понятия подразумеваемый адрес 
      и подразумеваемый операнд?</li>
<li>С какой целью в компьютерах применяются стеки?</li>
<li>Приведите пример преобразования арифметических выражений в форму, удобную 
      для использования в стеке с помощью ПОЛИЗ.</li>
<li>Приведите примеры структур одно-, двух- и трехадресных команд.</li>
<li>В каких случаях в компьютерах применяется автоинкрементная и автодекрементная 
      адресация?</li>
<li>Каким образом формируется исполнительный адрес при косвенной адресации?</li>
<li>Приведите пример использования относительной адресации.</li>
<li>Чем отличаются понятия структура команды и формат команды?</li>
</ol>
<p class="center"><a href="REGIND.html">Схема адресации</a> </p>
</body>
</html>
